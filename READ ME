Travail en binôme :
Pierre Courtemanche : Implémentation des classes Product, TVATaxCalculator, TvaTaxCalculatorTest, l'interface TaxCalculator et l'enum ProductType.
Christophe Saury : Implémentation des classes Invoice, InvoicePrinter, InvoiceTest, ImportedTaxCalculator et ImportedTaxCalculatorTest.

Concepts appliqués :
 - Clean Code
Nous avons veillé à utiliser des noms de variables et de méthodes clairs et explicites pour faciliter la compréhension du code.
Le code a été découpé en petites méthodes pour en faciliter la lecture et la maintenance.
De plus, nous avons regroupé les classes et les méthodes par responsabilité pour respecter le principe de responsabilité unique.
 - Functional Programming style
Nous avons utilisé des streams et des opérations fonctionnelles (comme mapToDouble et sum) pour simplifier les calculs sur les listes de produits.
Les méthodes statiques dans la classe TaxCalculator ont été utilisées pour éviter les effets de bord et faciliter les tests.
 - Test-Driven Development (TDD)
Nous avons créé des tests unitaires pour les classes Invoice et TaxCalculator avant d'implémenter les fonctionnalités.
Ces tests nous ont permis de valider le bon fonctionnement du code et faciliteront les modifications futures.
 - Design Pattern
Nous avons utilisé le pattern Enum pour représenter les différents types de produits et leurs taux de TVA associés (ProductType).
Nous avons utilisé le pattern Strategie pour rendre le calcul des taxes plus facil sa modification son extansion et sa réutilisation (TvaTaxCalculator,ImportedTaxCalculator).

Améliorations possibles :

Utiliser des interfaces pour définir des contrats entre les classes et faciliter l'évolution du code.
Implémenter des tests supplémentaires pour couvrir tous les cas d'utilisation et améliorer la robustesse du code.
Refactoriser le code pour séparer les préoccupations et faciliter la réutilisation et la maintenance du code.